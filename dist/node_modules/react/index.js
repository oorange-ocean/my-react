(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.React = {}));
})(this, (function (exports) { 'use strict';

    const currentDispatcher = {
        current: null,
    };
    const resolveDispatcher = () => {
        const dispatcher = currentDispatcher.current;
        if (dispatcher == null) {
            throw new Error("Hooks 只能在函数组件中执行");
        }
        return dispatcher;
    };

    // packages/shared/ReactSymbols.ts
    // 这段代码的主要目的是为 React 元素定义一个唯一的标识符。
    //它优先使用 Symbol 以获得更好的唯一性和性能，但也为不支持 Symbol 的环境提供了一个后备方案。
    //这种方法确保了 React 可以在各种 JavaScript 环境中正常工作。
    // 检查环境是否支持 Symbol 和 Symbol.for
    // typeof Symbol === "function" 检查 Symbol 是否可用
    // Symbol.for 是一个用于创建共享符号的方法
    const supportSymbol = typeof Symbol === "function" && Symbol.for;
    // 定义 REACT_ELEMENT_TYPE 常量
    // 这个常量用于标识 React 元素的类型
    const REACT_ELEMENT_TYPE = supportSymbol
        ? Symbol.for("react.element") // 如果支持 Symbol，使用 Symbol.for 创建一个唯一的共享符号
        : 0xeac7; // 如果不支持 Symbol，使用一个特定的数值作为后备方案
    // 0xeac7 是一个十六进制数，等于十进制的 60103
    // 这个数字被选作 React 元素类型的标识符，当环境不支持 Symbol 时使用

    // 导入 React 元素类型标识符
    /**
     * 创建 React 元素的函数
     * @param type 元素的类型（如 div、span 或自定义组件）
     * @param key 用于列表渲染的唯一标识符
     * @param ref 引用对象
     * @param props 元素的属性
     * @returns ReactElementType 返回创建的 React 元素对象
     */
    // 注意：这个 ReactElement 函数是 React 内部用来创建元素的基础方法。
    // 当我们在 JSX 中写组件时，它们最终会被转换成对这个函数的调用。
    // 这个实现简化了 React 的内部工作原理，用于创建可以被 React 识别和处理的元素结构。
    const ReactElement = function (type, key, ref, props) {
        // 创建 React 元素对象
        const element = {
            // $$typeof 用于标识这是一个 React 元素
            // 使用 $$ 前缀表示这是一个特殊的内部属性
            $$typeof: REACT_ELEMENT_TYPE,
            // type 使用对象字面量的简写语法，等同于 type: type
            type,
            key,
            ref,
            props,
            // 自定义标记，可能用于调试或特殊用途
            __mark: "gary",
        };
        // 返回创建的 React 元素对象
        return element;
    };
    // jsx 函数用于创建 React 元素这个 jsx 函数是 React 的核心部分
    //它负责将 JSX 语法转换为 React 元素。它处理了属性的提取、子元素的处理
    //并最终调用 ReactElement 函数创建 React 元素。
    //这个实现展示了 React 如何在内部处理 JSX 转换,是理解 React 工作原理的重要部分。
    const jsx = (type, config, ...children) => {
        // 初始化 key 和 ref
        let key = null;
        let ref = null;
        // 创建一个空的 props 对象
        const props = {};
        // 遍历 config 对象的所有属性
        for (const prop in config) {
            const val = config[prop];
            // 特殊处理 key 属性
            if (prop === "key") {
                if (val !== undefined) {
                    // 将 key 转换为字符串
                    key = "" + val;
                }
                continue; // 跳过后续处理
            }
            // 特殊处理 ref 属性
            if (prop === "ref") {
                if (val !== undefined) {
                    ref = val;
                }
                continue; // 跳过后续处理
            }
            // 检查属性是否直接属于 config 对象（非原型链上的属性）
            if ({}.hasOwnProperty.call(config, prop)) {
                // 将属性添加到 props 对象
                props[prop] = val;
            }
        }
        // 处理子元素
        const childrenLength = children.length;
        if (childrenLength) {
            if (childrenLength === 1) {
                // 如果只有一个子元素,直接赋值
                props.children = children[0];
            }
            else {
                // 如果有多个子元素,将它们作为数组赋值
                props.children = children;
            }
        }
        // 调用 ReactElement 函数创建 React 元素
        return ReactElement(type, key, ref, props);
    };

    // packages/react/index.ts
    const useState = (initialState) => {
        const dispatcher = resolveDispatcher();
        return dispatcher.useState(initialState);
    };
    // 内部数据共享层
    const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {
        currentDispatcher,
    };
    var index = {
        version: "1.0.0",
        createElement: jsx,
    };

    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    exports.default = index;
    exports.useState = useState;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
